8500/330
50*.25
50+12.5
10/50
64.99-25
install.packages("devtools")
install.packages("devtools", lib="C:\\Program Files\\R\\R-3.5.1\\library")
library(devtools)
devtools::check()
install.packages("root", lib="C:\\Program Files\\R\\R-3.5.1\\library")
devtools::install_github("MorphoFun/kraken")
devtools::install_github("MorphoFun/psa")
library(psa)
library(devtools)
install_github("MorphoFun/kraken")
library(signal)
install.packages("signal")
install.packages("signal", lib="C:\\Program Files\\R\\R-3.5.1\\library")
library(signal)
install_github("MorphoFun/kraken")
devtools::load_all()
install.packages("testthat", lib="C:\\Program Files\\R\\R-3.5.1\\library")
library(testthat)
testthat::test_path()
getwd()
getwd("C:/Users/sandy/Dropbox/kraken")
setwd("C:/Users/sandy/Dropbox/kraken")
install_github("MorphoFun/kraken")
install.packages("zoo", lib="C:\\Program Files\\R\\R-3.5.1\\library")
library(zoo)
install_github("MorphoFun/kraken")
devtools::document()
devtools::document()
devtools::document()
install_github("MorphoFun/kraken")
library(kraken)
shoulder <- matrix(c(0.006305306, 0.006526961, 0.006747555, -0.08206114, -0.08207707, -0.08207049, 0.006997669, 0.006980824, 0.006975157), 3, 3)
elbow <- matrix(c(0.007826633, 0.007959096, 0.008068560, -0.07183020, -0.07185459, -0.07186337, 0.005754819, 0.005764666, 0.005774707), 3, 3)
wrist <- matrix(c(0.01164592, 0.01160690, 0.01157642, -0.07348876, -0.07345559, -0.07342105, -0.000631402, -0.000671288, -0.000709513), 3, 3)
jointAngle(shoulder, elbow, wrist)
install_github("MorphoFun/kraken")
library(kraken)
jointAngle(shoulder, elbow, wrist)
devtools::document()
install_github("MorphoFun/kraken")
library(kraken)
jointAngle(shoulder, elbow, wrist)
jointAngle <- function(P1, P2, P3, ...) {
#### Create vectors of the XYZ coordinates for each anatomical landmark ####
# Assume that P2 is the vertex and P1 and P3 are the other two points that form the angle
# data are storted in df
# Most proximal joint (e.g., Shoulder, S) XYZ are columns 1 - 3,
# Middle joint (e.g., elbow, E) XYZ are 4-6, and
# most distal joint (e.g., wrist, W) XYZ are 7 - 9
# Only focusing on first row for now
# norm is the Euclidean norm of a vector, which can be calculated in R using
Euc_norm <- function(x) sqrt(sum(x^2))
# To produce a vector cross-product:
vec_cross <- function(ab,ac){
abci = ab[2] * ac[3] - ac[2] * ab[3];
abcj = ac[1] * ab[3] - ab[1] * ac[3];
abck = ab[1] * ac[2] - ac[1] * ab[2];
return (c(abci, abcj, abck))
}
P32 <- matrix(0, 3, 3)
P12 <- matrix(0, 3, 3)
for (i in 1:nrow(P1)) {
if (isTRUE(is.vector(P1))) {
# Create vectors of the P3-P2 and P1-P2 segments
P32 <- as.numeric(P3 - P2)
P12 <- as.numeric(P1 - P2)
angle_degrees <- atan2(Euc_norm(vec_cross(P32, P12)), sum(P32 * P12))*(180/pi)
} else {
# Create vectors of the P3-P2 and P1-P2 segments
P32[i,] <- as.numeric(P3[i,] - P2[i,])
P12[i,] <- as.numeric(P1[i,] - P2[i,])
angle_degrees[i] <- atan2(Euc_norm(vec_cross(P32[i,], P12[i,])), sum(P32[i,] * P12[i,]))*(180/pi)
}
}
print(angle_degrees)
}
jointAngle(shoulder, elbow, wrist)
P1 <- shoulder
P2 <- elbow
P3 <- writ
P3 <- wrist
for (i in 1:nrow(P1)) {
if (isTRUE(is.vector(P1))) {
# Create vectors of the P3-P2 and P1-P2 segments
P32 <- as.numeric(P3 - P2)
P12 <- as.numeric(P1 - P2)
angle_degrees <- atan2(Euc_norm(vec_cross(P32, P12)), sum(P32 * P12))*(180/pi)
} else {
# Create vectors of the P3-P2 and P1-P2 segments
P32[i,] <- as.numeric(P3[i,] - P2[i,])
P12[i,] <- as.numeric(P1[i,] - P2[i,])
angle_degrees[i] <- atan2(Euc_norm(vec_cross(P32[i,], P12[i,])), sum(P32[i,] * P12[i,]))*(180/pi)
}
}
P32 <- matrix(0, 3, 3)
P12 <- matrix(0, 3, 3)
for (i in 1:nrow(P1)) {
if (isTRUE(is.vector(P1))) {
# Create vectors of the P3-P2 and P1-P2 segments
P32 <- as.numeric(P3 - P2)
P12 <- as.numeric(P1 - P2)
angle_degrees <- atan2(Euc_norm(vec_cross(P32, P12)), sum(P32 * P12))*(180/pi)
} else {
# Create vectors of the P3-P2 and P1-P2 segments
P32[i,] <- as.numeric(P3[i,] - P2[i,])
P12[i,] <- as.numeric(P1[i,] - P2[i,])
angle_degrees[i] <- atan2(Euc_norm(vec_cross(P32[i,], P12[i,])), sum(P32[i,] * P12[i,]))*(180/pi)
}
}
Euc_norm <- function(x) sqrt(sum(x^2))
# To produce a vector cross-product:
vec_cross <- function(ab,ac){
abci = ab[2] * ac[3] - ac[2] * ab[3];
abcj = ac[1] * ab[3] - ab[1] * ac[3];
abck = ab[1] * ac[2] - ac[1] * ab[2];
return (c(abci, abcj, abck))
Euc_norm <- function(x) sqrt(sum(x^2))
# To produce a vector cross-product:
vec_cross <- function(ab,ac){
abci = ab[2] * ac[3] - ac[2] * ab[3];
abcj = ac[1] * ab[3] - ab[1] * ac[3];
abck = ab[1] * ac[2] - ac[1] * ab[2];
return (c(abci, abcj, abck))
}
P32 <- matrix(0, 3, 3)
P12 <- matrix(0, 3, 3)
for (i in 1:nrow(P1)) {
if (isTRUE(is.vector(P1))) {
# Create vectors of the P3-P2 and P1-P2 segments
P32 <- as.numeric(P3 - P2)
P12 <- as.numeric(P1 - P2)
angle_degrees <- atan2(Euc_norm(vec_cross(P32, P12)), sum(P32 * P12))*(180/pi)
} else {
# Create vectors of the P3-P2 and P1-P2 segments
P32[i,] <- as.numeric(P3[i,] - P2[i,])
P12[i,] <- as.numeric(P1[i,] - P2[i,])
angle_degrees[i] <- atan2(Euc_norm(vec_cross(P32[i,], P12[i,])), sum(P32[i,] * P12[i,]))*(180/pi)
}
}
?seq
# norm is the Euclidean norm of a vector, which can be calculated in R using
Euc_norm <- function(x) sqrt(sum(x^2))
# To produce a vector cross-product:
vec_cross <- function(ab,ac){
abci = ab[2] * ac[3] - ac[2] * ab[3];
abcj = ac[1] * ab[3] - ab[1] * ac[3];
abck = ab[1] * ac[2] - ac[1] * ab[2];
return (c(abci, abcj, abck))
}
P32 <- matrix(0, 3, 3)
P12 <- matrix(0, 3, 3)
angle_degrees <- vector()
for (i in 1:nrow(P1)) {
if (isTRUE(is.vector(P1))) {
# Create vectors of the P3-P2 and P1-P2 segments
P32 <- as.numeric(P3 - P2)
P12 <- as.numeric(P1 - P2)
angle_degrees <- atan2(Euc_norm(vec_cross(P32, P12)), sum(P32 * P12))*(180/pi)
} else {
# Create vectors of the P3-P2 and P1-P2 segments
P32[i,] <- as.numeric(P3[i,] - P2[i,])
P12[i,] <- as.numeric(P1[i,] - P2[i,])
angle_degrees[i] <- atan2(Euc_norm(vec_cross(P32[i,], P12[i,])), sum(P32[i,] * P12[i,]))*(180/pi)
}
}
angle_degrees
jointAngle <- function(P1, P2, P3, ...) {
#### Create vectors of the XYZ coordinates for each anatomical landmark ####
# Assume that P2 is the vertex and P1 and P3 are the other two points that form the angle
# data are storted in df
# Most proximal joint (e.g., Shoulder, S) XYZ are columns 1 - 3,
# Middle joint (e.g., elbow, E) XYZ are 4-6, and
# most distal joint (e.g., wrist, W) XYZ are 7 - 9
# Only focusing on first row for now
# norm is the Euclidean norm of a vector, which can be calculated in R using
Euc_norm <- function(x) sqrt(sum(x^2))
# To produce a vector cross-product:
vec_cross <- function(ab,ac){
abci = ab[2] * ac[3] - ac[2] * ab[3];
abcj = ac[1] * ab[3] - ab[1] * ac[3];
abck = ab[1] * ac[2] - ac[1] * ab[2];
return (c(abci, abcj, abck))
}
P32 <- matrix(0, 3, 3)
P12 <- matrix(0, 3, 3)
angle_degrees <- numeric(length = nrow(P1))
for (i in 1:nrow(P1)) {
if (isTRUE(is.vector(P1))) {
# Create vectors of the P3-P2 and P1-P2 segments
P32 <- as.numeric(P3 - P2)
P12 <- as.numeric(P1 - P2)
angle_degrees <- atan2(Euc_norm(vec_cross(P32, P12)), sum(P32 * P12))*(180/pi)
} else {
# Create vectors of the P3-P2 and P1-P2 segments
P32[i,] <- as.numeric(P3[i,] - P2[i,])
P12[i,] <- as.numeric(P1[i,] - P2[i,])
angle_degrees[i] <- atan2(Euc_norm(vec_cross(P32[i,], P12[i,])), sum(P32[i,] * P12[i,]))*(180/pi)
}
}
print(angle_degrees)
}
############# GRFangles ##########
## assumes that your time component is in the first column and is followed by three columns containing the components of the GRF
## assumes that the order is Vert, ML, and AP
## must be data.frame
GRFangles <- function(myData, ...) {
# Calculating the angles of orientation
myData$GRF_Vert_Sq <- myData[,2]^2
myData$GRF_ML_Sq <- myData[,3]^2
myData$GRF_AP_Sq <- myData[,4]^2
myData$NetGRF_N <- sqrt(myData$GRF_Vert_Sq + myData$GRF_ML_Sq + myData$GRF_AP_Sq)
myData$MLAngle <- (acos(myData[,3]/(sqrt(myData$GRF_ML_Sq + myData$GRF_Vert_Sq))))*(180/pi)
myData$MLAngle_Convert <- 90 - myData$MLAngle
myData$APAngle <- (acos(myData[,4]/(sqrt(myData$GRF_AP_Sq + myData$GRF_Vert_Sq))))*(180/pi)
myData$APAngle_Convert <- 90 - myData$APAngle
output <- data.frame(myData[,1:5], myData$NetGRF_N, myData$MLAngle, myData$MLAngle_Convert, myData$APAngle, myData$APAngle_Convert)
}
jointAngle(shoulder, elbow, wrist)
rm(angle_degrees)
rm(jointAngle())
install_github("MorphoFun/kraken")
library(kraken)
jointAngle(shoulder, elbow, wrist)
jointAngle
jointAngle()
?jointAngle
install_github("MorphoFun/kraken")
library(kraken)
?jointAngle
devtools::document()
install_github("MorphoFun/kraken")
library(kraken)
?jointAngle
?lm
?jointAngle
?jointAngle
devtools::document()
install_github("MorphoFun/kraken")
install_github("MorphoFun/kraken", force = TRUE)
library(kraken)
?jointAngle
