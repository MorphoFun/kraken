31/34
2+3+4+2+0.25+2+5+2.5+2.5
2+2+2.75+0.5+1+0.5
23.35+8.75
23.25+8.75
2+2+2+2.75+1+0.5+0.5
23.25+10.75
5*51
255/60
8*51
408/60
2+2+2+3+2+2+3+2+2.75+3+5.75
2+1+1+0.25+0.25
29.5+4.5
2+2+5+2.5+1.25+1+2+2+3+3+4
1+1+0.5+1.75+1+1
27.75+6.25
1+2+3+3+3+1+2+2+3+4+4
2+3+1
28+6
28/34
2+2+4+3+3+1+2+2+4+1.75+2
1+2+1+3+0.25
26.75+7.25
1.5+2+4+1+2.5+2+1+2+2+1+1.75
1.5+2+2+0.5+1+1+3+0.25+2
20.75+13.25
2.25+2+4+2.5+2+2+2+2+2+4+2
0.75+2+0.5+1+1+2
26.75+7.25
26.75/34
2+2+2+3+2+2+1+3+4+2+3
2+1+2+1
28+6
0.25+2+2.5+2+3+2+2+8
2.75+3.5+1+2+1+2
21.75+12.25
2.5+2+4.5+2+1+1.5+2+1+1.75+2
0.5+1.5+1+3+1+0.5+3+3+0.25
20.25+13.75
2.5+2+6+3+3+2+2+2+1+4+2
0.5+2+2
29.5+4.5
2+2+2+3+2+2+2+2+2.75+3+6+2
2+0.25+1
1+3++2+2+2+0.25+2.5+2.5+3
1+1+2+3+2+2.75+0.5+0.5+3
18.25+15.75
-log(3)
-log(300)
-log(3000)
-log(.3000)
-log(.5000)
-log(0.1)
-log(0.3)
-log(0.5)
23*5
23*6
2*60
120+45
50/4
#### Osmoregulation and Osmoconforming in marine invertebrates ####
#### Load in the libraries ####
library(ggplot2)
#### Load in the data ####
## Load in the data from your computer
lab05_data <- read.csv(file.choose(), header = TRUE)
af07f08_Pec <- read.csv(file.choose())
head(af07f08_Pec)
### load the libraries
library(devtools)
install_github("MorphoFun/kraken", dependencies = TRUE)
library(kraken) # use for kraken::jointAngle()
library(signal) # use for signal::interp1()
library(pspline) # use for pspline::smooth.Pspline()
library(ggplot2) # for plotting
library(reshape2) # use for reshape2::melt()
?jointAngle
elbowAngle(af07f08_Pec[,7:9], af07f08_Pec[,10:12], af07f08_Pec[,13:15])
elbowAngle <- jointAngle(af07f08_Pec[,7:9], af07f08_Pec[,10:12], af07f08_Pec[,13:15])
elbowAngle
wristAngle <- jointAngle(af07f08_Pec[,10:12], af07f08_Pec[,13:15], af07f08_Pec[,19:21])
wristAngle
wristAngle <- jointAngle(af07f08_Pec[,10:12], af07f08_Pec[,13:15], af07f08_Pec[,16:18])
wristAngle
head(af07f08_Pec)
SegVectorBackY <- P1[,2] - P2[,2]
SegVectorBackX <- P1[,1] - P2[,1]
P1 <- af07f08_Pec[,1:3]
P2 <- af07f08_Pec[,4:6]
SegVectorBackY <- P1[,2] - P2[,2]
SegVectorBackX <- P1[,1] - P2[,1]
TanYaw <- SegVectorBackY./SegVectorBackX;
TanYaw <- SegVectorBackY/SegVectorBackX;
yaw <- (atan(TanYaw))
yaw
yaw <- (atan(TanYaw))*(pi/180)
yaw
yaw <- (atan2(TanYaw))*(pi/180)
TanYaw <- SegVectorBackY %*% solve(SegVectorBackX);
SegVectorBackX
TanYaw <- solve(t(SegVectorBackY), SegVectorBackX);
?mrdivide
library(pracma)
?mrdivide
TanYaw <- mrdivide(SegVectorBackY, SegVectorBackX)
yaw <- (atan(TanYaw))*(pi/180)
yaw
?atan2
atan(SegVectorBackY, SegVectorBackX)
SegVectorBackX
?matrix
matrix(c(8, 1, 6, 3, 5, 7, 4, 9, 2), 3, 3)
matrix(c(8, 1, 6, 3, 5, 7, 4, 9, 2), 3, 3, byrow = TRUE)
a <- matrix(c(8, 1, 6, 3, 5, 7, 4, 9, 2), 3, 3, byrow = TRUE)
b <- matrix(c(3, 3, 4, 1, 2, 4, 3, 1, 2), 3, 3, byrow = TRUE)
b
a/b
?atan
yaw <- (atan(TanYaw))*(pi/180)
TanYaw <- SegVectorBackY/SegVectorBackX
yaw <- (atan(TanYaw))*(pi/180)
yaw
yaw <- (atan(TanYaw))*(180/pi)
yaw
0.004978444
0.005226819
0.005483069
0.005747358
0.006019848
0.006300701
0.006590101
0.00688825
0.007195354
P1
P1 <- data.frame(X = c(0.004978444,
0.005226819,
0.005483069,
0.005747358,
0.006019848,
0.006300701,
0.006590101,
0.00688825,
0.007195354),
Y = c(-0.09374413,
-0.09380451,
-0.09382974,
-0.09382203,
-0.09378361,
-0.09371668,
-0.09362362,
-0.09350694,
-0.09336917
))
P1
P2 <- data.frame(X = c(0.001005251,
0.001195392,
0.001406054,
0.001636047,
0.001884185,
0.002149271,
0.002429912,
0.002724486,
0.003031363),
Y = c(-0.09343679,
-0.09347614,
-0.09350069,
-0.09350983,
-0.09350293,
-0.09347937,
-0.09343846,
-0.09337947,
-0.09330165
))
P2
yaw(P1, P2)
yaw <- function(P1, P2, ...) {
SegVectorBackY <- P1[,2] - P2[,2]
SegVectorBackX <- P1[,1] - P2[,1]
TanYaw <- SegVectorBackY/SegVectorBackX
yaw <- (atan(TanYaw))*(180/pi)
}
yaw(P1, P2)
yaw <- function(P1, P2, ...) {
SegVectorBackY <- P1[,2] - P2[,2]
SegVectorBackX <- P1[,1] - P2[,1]
TanYaw <- SegVectorBackY/SegVectorBackX
yaw <- (atan(TanYaw))*(180/pi)
output(yaw)
}
yaw(P1, P2)
yaw <- function(P1, P2, ...) {
SegVectorBackY <- P1[,2] - P2[,2]
SegVectorBackX <- P1[,1] - P2[,1]
TanYaw <- SegVectorBackY/SegVectorBackX
yaw <- (atan(TanYaw))*(180/pi)
return(yaw)
}
yaw(P1, P2)
P1 <- data.frame(X = c(0.004978444,
0.005226819,
0.005483069,
0.005747358,
0.006019848,
0.006300701,
0.006590101,
0.00688825,
0.007195354,
0.007511617),
Y = c(-0.09374413,
-0.09380451,
-0.09382974,
-0.09382203,
-0.09378361,
-0.09371668,
-0.09362362,
-0.09350694,
-0.09336917,
-0.09321286
))
P2 <- data.frame(X = c(0.001005251,
0.001195392,
0.001406054,
0.001636047,
0.001884185,
0.002149271,
0.002429912,
0.002724486,
0.003031363,
0.003348911),
Y = c(-0.09343679,
-0.09347614,
-0.09350069,
-0.09350983,
-0.09350293,
-0.09347937,
-0.09343846,
-0.09337947,
-0.09330165,
-0.09320426
))
yaw(P1, P2)
install_github("MorphoFun/kraken", dependencies = TRUE)
install_github("MorphoFun/kraken", dependencies = TRUE)
devtools::document()
setwd("C:/Users/sandy/Dropbox/kraken")
devtools::document()
devtools::document()
devtools::document()
install_github("MorphoFun/kraken", dependencies = TRUE)
devtools::document()
devtools::document()
traceback()
Version()
VersionInfo()
??version
R.Version()
install.packages(installr)
install.packages("installr")
library(installr)
updateR()
# Determining the date you're running these analyses
today <- Sys.Date()
SaveDate <- format(today, format="%y%m%d")
# Read in values to calibrate each GRF component by; uses most recent Calibration Overview file
# when using list.files, need to use setwd as an assigned variable and also by itlself (see below) or it won't work
CalibFile <- data.frame(read.csv("./dataraw/FinLimbGRFs_Calibs.csv", header=TRUE))
CalibFile
# Read the most recent Video Info file
VideoFile <- data.frame(read.csv("./dataraw/FinLimbGRFs_VideoInfo.csv", header=TRUE))
VideoFile
setwd('./dataraw')
myFile <- file.choose()
myData <- read.table(myFile, header=FALSE)
myData <- myData[,c(1:12)] # Last 4 columns/channels were unused, so only subsetting what I need
names(myData) <- c("Light.Volts", "Vert1.Volts", "Vert2.Volts", "Vert3.Volts", "Vert4.Volts", "VertSum.Volts", "ML1.Volts", "ML2.Volts", "MLSum.Volts", "Hz1.Volts", "Hz2.Volts", "HzSum.Volts")
myData$Sweep <- 1:nrow(myData)
MyFile
myData
myFile
?substring
substring(myFile, length(myFile)-5, length(myFile))
length(myFile)-5
length(myFile)
nchar(myFile)
substring(myFile, nchar(myFile)-5, nchar(myFile))
substring(myFile, nchar(myFile)-9, nchar(myFile)-4)
substring(myFile, nchar(myFile)-10, nchar(myFile)-4)
# Looking up video info
# Appendages listed as "Both" have both pectoral and pelvic appendage data
VideoInfo <- VideoFile[VideoFile$File.name %in% Trial,]
# Determining trial name and data collectiond date
Trial <-  substring(myFile, nchar(myFile)-10, nchar(myFile)-4)
# Looking up video info
# Appendages listed as "Both" have both pectoral and pelvic appendage data
VideoInfo <- VideoFile[VideoFile$File.name %in% Trial,]
VideoInfo
Date <- VideoInfo$Date.Filmed
Date
str(Date)
# Calibrating the raw force data and converting to newtons (if needed)
CalibInfo <- CalibFile[CalibFile$Date %in% Date,]
CalibInfo
Date <- levels(VideoInfo$Date.Filmed)
Date
class(VideoInfo$Date.Filmed)
Date <- as.numeric(VideoInfo$Date.Filmed)
Date
?as.Date
Date <- as.Date(VideoInfo$Date.Filmed)
Date <- as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%Y")
Date
Date <- as.Date(VideoInfo$Date.Filmed, format = "%Y/%m/%d")
Date
Date <- as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y")
Date
# Calibrating the raw force data and converting to newtons (if needed)
CalibInfo <- CalibFile[CalibFile$Date %in% Date,]
CalibInfo
CalibInfo
CalibFile
as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y")
as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%Y")
Date
as.Date(VideoInfo$Date.Filmed, format = "%m%d%y")
as.Date(VideoInfo$Date.Filmed, format = "%m %d %y")
as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y")
Date <- format(date(as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y"), "%y/%m/%d"))
Date <- as.Date(VideoInfo$Date.Filmed, format = "%m%d%y")
Date
Date <- as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y")
SaveDate
today
Date <- format(as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y"), format="%y%m%d"))
Date <- format(as.Date(VideoInfo$Date.Filmed, format = "%m/%d/%y"), format="%y%m%d")
Date
# Calibrating the raw force data and converting to newtons (if needed)
CalibInfo <- CalibFile[CalibFile$Date %in% Date,]
CalibInfo
myData$VertSumCalib.N <- myData$VertSum.Volts*CalibInfo$Vert.Calib
myData$MLSumCalib.N <- myData$MLSum.Volts*CalibInfo$ML.Calib
myData$HzSumCalib.N <- myData$HzSum.Volts*CalibInfo$Hz.Calib
# Putting forces in terms of GRF (which is opposite in direction to the force produced by the limb onto the force plate)
myData$GRF.VertSumCalib.N <- myData$VertSumCalib.N # Already made negative based on the calibration calculations conducted earlier in the excel calibration files
myData$GRF.MLSumCalib.N <- -myData$MLSumCalib.N
myData$GRF.HzSumCalib.N <- myData$HzSumCalib.N # Rotating the force plate results in the signage changes, so don't need to multiply by -1
# Determining what sweep number the light is turned on, so I can sync with video frames
LightSwitch <- myData[which(myData$Light.Volts<0),]
LightOnset <- LightSwitch[which(LightSwitch$Sweep == min(LightSwitch$Sweep)),]
# Synching video frames with force sweep numbers
# *50 is due to the conversion from sweeps to frames (5000 Hz for force/100 Hz for video)
if (!is.na(VideoInfo$Pectoral.Start.Frame)) PectoralStartSweep <- LightOnset$Sweep-((VideoInfo$Light.Start-VideoInfo$Pectoral.Start.Frame)*50)
if (!is.na(VideoInfo$Pectoral.End.Frame)) PectoralEndSweep <- LightOnset$Sweep-((VideoInfo$Light.Start-VideoInfo$Pectoral.End.Frame)*50)
if (!is.na(VideoInfo$Pelvic.Start.Frame)) PelvicStartSweep <- LightOnset$Sweep-((VideoInfo$Light.Start-VideoInfo$Pelvic.Start.Frame)*50)
if (!is.na(VideoInfo$Pelvic.End.Frame)) PelvicEndSweep <- LightOnset$Sweep-((VideoInfo$Light.Start-VideoInfo$Pelvic.End.Frame)*50)
# Calculating the difference between the force trace zero and what should really be zero on the force trace (i.e., calculating horizontal offset)
# First, determine whether the pectoral or pelvic appendages appear first on the force trace
if (VideoInfo$Appendages == 'Pectoral') First <- data.frame(PectoralStartSweep)
if (VideoInfo$Appendages == 'Both') First <- data.frame(PectoralStartSweep,PelvicStartSweep)
FirstTrace <- First[which(First==min(First))]
OffsetCalcStart <- (FirstTrace[1,1])-2000
if (VideoInfo$Appendages == 'Pelvic') First <- data.frame(PelvicStartSweep)
OffsetCalcEnd <- (FirstTrace[1,1])-1000
GRF.VertSumCalib.N.Offset <- mean(myData$GRF.VertSumCalib.N[OffsetCalcStart:OffsetCalcEnd])
GRF.MLSumCalib.N.Offset <- mean(myData$GRF.MLSumCalib.N[OffsetCalcStart:OffsetCalcEnd])
GRF.HzSumCalib.N.Offset <- mean(myData$GRF.HzSumCalib.N[OffsetCalcStart:OffsetCalcEnd])
# Zeroing the force trace data using the horizontal offset value
myData$GRF.VertSumCalib.N.Zero <- myData$GRF.VertSumCalib.N-GRF.VertSumCalib.N.Offset
myData$GRF.MLSumCalib.N.Zero <- myData$GRF.MLSumCalib.N-GRF.MLSumCalib.N.Offset
myData$GRF.HzSumCalib.N.Zero <- myData$GRF.HzSumCalib.N-GRF.HzSumCalib.N.Offset
# Plotting force traces
if (VideoInfo$Appendages == 'Pectoral') Last <- data.frame(PectoralEndSweep)
if (VideoInfo$Appendages == 'Pelvic') Last <- data.frame(PelvicEndSweep)
if (VideoInfo$Appendages == 'Both') Last <- data.frame(PectoralEndSweep, PelvicEndSweep)
LastTrace <- Last[which(Last==max(Last))]
PlotStart <- FirstTrace[1,1]-1000
PlotEnd <- LastTrace[1,1]+1000
if (!is.na(VideoInfo$Pectoral.Start.Frame) & !is.na(VideoInfo$Pelvic.Start.Frame)) {
ImpPointsX <- data.frame(PectoralStartSweep, PectoralEndSweep,PelvicStartSweep, PelvicEndSweep)
names(ImpPointsX) <- c('Pectoral Start', 'Pectoral End','Pelvic Start', 'Pelvic End') }
if (!is.na(VideoInfo$Pectoral.Start.Frame) & is.na(VideoInfo$Pelvic.Start.Frame)) {
ImpPointsX <- data.frame(PectoralStartSweep, PectoralEndSweep)
names(ImpPointsX) <- c('Pectoral Start', 'Pectoral End') }
if (is.na(VideoInfo$Pectoral.Start.Frame) & !is.na(VideoInfo$Pelvic.Start.Frame)) {
ImpPointsX <- data.frame(PelvicStartSweep, PelvicEndSweep)
names(ImpPointsX) <- c('Pelvic Start', 'Pelvic End') }
attach(myData)
if (!is.na(VideoInfo$Pectoral.Start.Frame) & is.na(VideoInfo$Pelvic.Start.Frame)) {
ImpPoints.GRFVert <- data.frame(GRF.VertSumCalib.N.Zero[PectoralStartSweep], GRF.VertSumCalib.N.Zero[PectoralEndSweep])
ImpPoints.GRFML <- data.frame(GRF.MLSumCalib.N.Zero[PectoralStartSweep], GRF.MLSumCalib.N.Zero[PectoralEndSweep])
ImpPoints.GRFHz <- data.frame(GRF.HzSumCalib.N.Zero[PectoralStartSweep], GRF.HzSumCalib.N.Zero[PectoralEndSweep])
}
if (is.na(VideoInfo$Pectoral.Start.Frame) & !is.na(VideoInfo$Pelvic.Start.Frame)) {
ImpPoints.GRFVert <- data.frame(GRF.VertSumCalib.N.Zero[PelvicStartSweep], GRF.VertSumCalib.N.Zero[PelvicEndSweep])
ImpPoints.GRFML <- data.frame(GRF.MLSumCalib.N.Zero[PelvicStartSweep], GRF.MLSumCalib.N.Zero[PelvicEndSweep])
ImpPoints.GRFHz <- data.frame(GRF.HzSumCalib.N.Zero[PelvicStartSweep], GRF.HzSumCalib.N.Zero[PelvicEndSweep])
}
if (!is.na(VideoInfo$Pectoral.Start.Frame) & !is.na(VideoInfo$Pelvic.Start.Frame)) {
ImpPoints.GRFVert <- data.frame(GRF.VertSumCalib.N.Zero[PectoralStartSweep], GRF.VertSumCalib.N.Zero[PectoralEndSweep], GRF.VertSumCalib.N.Zero[PelvicStartSweep], GRF.VertSumCalib.N.Zero[PelvicEndSweep])
ImpPoints.GRFML <- data.frame(GRF.MLSumCalib.N.Zero[PectoralStartSweep], GRF.MLSumCalib.N.Zero[PectoralEndSweep], GRF.MLSumCalib.N.Zero[PelvicStartSweep], GRF.MLSumCalib.N.Zero[PelvicEndSweep])
ImpPoints.GRFHz <- data.frame(GRF.HzSumCalib.N.Zero[PectoralStartSweep], GRF.HzSumCalib.N.Zero[PectoralEndSweep], GRF.HzSumCalib.N.Zero[PelvicStartSweep], GRF.HzSumCalib.N.Zero[PelvicEndSweep])
}
detach(myData)
quartz(width=10)
par(mfrow=c(1,3), oma = c(0, 0, 2, 0))  # oma = outer margin with 2 lines above the top of the graphs
# Vertical component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.VertSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Vertical (N)', main='Zeroed GRF (Vertical) Force', type="l", col="blue")
points(ImpPointsX[1,], ImpPoints.GRFVert[1,], type='p', pch='O', col='cyan')
text(ImpPointsX[1,], ImpPoints.GRFVert[1,], labels=names(ImpPointsX), pos=3, font=2) # pos: 1 = below, 2 = left, 3 = above, 4 = right
# Mediolateral component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.MLSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Mediolateral (N)', main='Zeroed GRF (Mediolateral) Force', type="l", col="red")
points(ImpPointsX[1,], ImpPoints.GRFML[1,], type='p', pch='O', col='cyan')
text(ImpPointsX[1,], ImpPoints.GRFML[1,], labels=names(ImpPointsX), pos=3, font=2) # pos: 1 = below, 2 = left, 3 = above, 4 = right
# Horizontal (Anteroposterior) component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.HzSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Horizontal (N)', main='Zeroed GRF (Horizontal) Force', type="l", col="forestgreen")
points(ImpPointsX[1,], ImpPoints.GRFHz[1,], type='p', pch='O', col='cyan')
text(ImpPointsX[1,], ImpPoints.GRFHz[1,], labels=names(ImpPointsX), pos=3, font=2) # pos: 1 = below, 2 = left, 3 = above, 4 = right
mtext(Trial, line=0.5, outer=TRUE)  # writes an overall title over the graphs
# For saving as pdf
PdfSave <- paste(substring(myFile, 1, 74), "R Analysis/Step 1 Calibrate and Organize Data/Save All Data/", Trial, "_Filter_", SaveDate, ".pdf", sep="")
pdf(PdfSave, width=11)
par(mfrow=c(1,3), oma = c(0, 0, 2, 0))  # oma = outer margin with 2 lines above the top of the graphs
# Vertical component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.VertSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Vertical (N)', main='Zeroed GRF (Vertical) Force', type="l", col="blue")
par(mfrow=c(1,3), oma = c(0, 0, 2, 0))  # oma = outer margin with 2 lines above the top of the graphs
# Vertical component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.VertSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Vertical (N)', main='Zeroed GRF (Vertical) Force', type="l", col="blue")
points(ImpPointsX[1,], ImpPoints.GRFVert[1,], type='p', pch='O', col='cyan')
text(ImpPointsX[1,], ImpPoints.GRFVert[1,], labels=names(ImpPointsX), pos=3, font=2) # pos: 1 = below, 2 = left, 3 = above, 4 = right
# Mediolateral component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.MLSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Mediolateral (N)', main='Zeroed GRF (Mediolateral) Force', type="l", col="red")
points(ImpPointsX[1,], ImpPoints.GRFML[1,], type='p', pch='O', col='cyan')
text(ImpPointsX[1,], ImpPoints.GRFML[1,], labels=names(ImpPointsX), pos=3, font=2) # pos: 1 = below, 2 = left, 3 = above, 4 = right
# Horizontal (Anteroposterior) component of GRF graph
plot(myData$Sweep[PlotStart:PlotEnd], myData$GRF.HzSumCalib.N.Zero[PlotStart:PlotEnd], xlab='Sweep', ylab='GRF - Horizontal (N)', main='Zeroed GRF (Horizontal) Force', type="l", col="forestgreen")
points(ImpPointsX[1,], ImpPoints.GRFHz[1,], type='p', pch='O', col='cyan')
text(ImpPointsX[1,], ImpPoints.GRFHz[1,], labels=names(ImpPointsX), pos=3, font=2) # pos: 1 = below, 2 = left, 3 = above, 4 = right
mtext(Trial, line=0.5, outer=TRUE)  # writes an overall title over the graphs
dev.off()  # for use with pdf()
# Preparing the data to be filtered
# Pectoral appendage stance
if (!VideoInfo$Appendages == 'Pelvic') {
# Calculating the range of sweeps for your stance
StanceSweeps.Pec <- myData$Sweep[PectoralStartSweep:PectoralEndSweep]
# Leaving extra sweeps in front and back of trace to reduce likelihood of edge effects (Extra sweeps = 25% of stance duration)
Extra.Pec <- round(.25*length(StanceSweeps.Pec))
FilterPrep.Sweeps.Pec <- myData$Sweep[c(PectoralStartSweep-Extra.Pec):c(PectoralEndSweep+Extra.Pec)]
FilterGRFVert.Pec <- myData$GRF.VertSumCalib.N.Zero[c(PectoralStartSweep-Extra.Pec):c(PectoralEndSweep+Extra.Pec)]
FilterGRFML.Pec <- myData$GRF.MLSumCalib.N.Zero[c(PectoralStartSweep-Extra.Pec):c(PectoralEndSweep+Extra.Pec)]
FilterGRFHz.Pec <- myData$GRF.HzSumCalib.N.Zero[c(PectoralStartSweep-Extra.Pec):c(PectoralEndSweep+Extra.Pec)]
FilterPrep.Pec <- data.frame(FilterPrep.Sweeps.Pec,FilterGRFVert.Pec, FilterGRFML.Pec, FilterGRFHz.Pec)
names(FilterPrep.Pec) <- c('Sweep', 'GRF0SumVN', 'GRF0SumMLN', 'GRF0SumHzN')
}
if (!VideoInfo$Appendages == 'Pectoral') {
StanceSweeps.Pel <- myData$Sweep[PelvicStartSweep:PelvicEndSweep]
Extra.Pel <- round(.25*length(StanceSweeps.Pel))
FilterPrep.Sweeps.Pel <- myData$Sweep[c(PelvicStartSweep-Extra.Pel):c(PelvicEndSweep+Extra.Pel)]
FilterGRFVert.Pel <- myData$GRF.VertSumCalib.N.Zero[c(PelvicStartSweep-Extra.Pel):c(PelvicEndSweep+Extra.Pel)]
FilterGRFML.Pel <- myData$GRF.MLSumCalib.N.Zero[c(PelvicStartSweep-Extra.Pel):c(PelvicEndSweep+Extra.Pel)]
FilterGRFHz.Pel <- myData$GRF.HzSumCalib.N.Zero[c(PelvicStartSweep-Extra.Pel):c(PelvicEndSweep+Extra.Pel)]
FilterPrep.Pel <- data.frame(FilterPrep.Sweeps.Pel,FilterGRFVert.Pel, FilterGRFML.Pel, FilterGRFHz.Pel)
names(FilterPrep.Pel) <- c('Sweep', 'GRF0SumVN', 'GRF0SumMLN', 'GRF0SumHzN')
}
# Saving all of the data
setwd('/Users/SandyMKawano/Desktop/Research/Forelimbs on Force Plates/Force Data/R Analysis/Step 1 Calibrate and Organize Data/Save All Data')
SaveAllDataName <- paste(Trial,"_AllPrep_",SaveDate, ".csv", sep="")
write.table(myData, file=SaveAllDataName, sep =",", row.names=FALSE)
# Saving the filter prep data
# Butterworth filtering will be conducted using another set of R code
# First, code the date that the file is being saved
if (!VideoInfo$Appendages == 'Pelvic') SaveFileName.Pec <- paste(Trial,"_FilterPrepPec_", SaveDate, ".csv", sep="")
if (!VideoInfo$Appendages == 'Pectoral') SaveFileName.Pel <- paste(Trial,"_FilterPrepPel_", SaveDate, ".csv", sep="")
# Changing directory
setwd('/Users/SandyMKawano/Desktop/Research/Forelimbs on Force Plates/Force Data/R Analysis/Step 1 Calibrate and Organize Data/Prep Data for Filtering')
if (!VideoInfo$Appendages == 'Pelvic') write.table(FilterPrep.Pec, file=SaveFileName.Pec, sep =",", row.names=FALSE)
if (!VideoInfo$Appendages == 'Pectoral') write.table(FilterPrep.Pel, file=SaveFileName.Pel, sep =",", row.names=FALSE)
# Changing directory for saving the figure of the graphs
setwd('/Users/SandyMKawano/Desktop/Research/Forelimbs on Force Plates/Force Data/R Analysis/Step 1 Calibrate and Organize Data/Save All Data')
if (!require("devtools")) {
install.packages("devtools", dependencies = TRUE)
library(devtools)
}
?install_github
install_github("MorphoFun/kraken")
install_github("MorphoFun/kraken")
?rlang
install.packages("rlang")
install.packages("rlang")
install_github("MorphoFun/kraken")
library(devtools)
install_github("MorphoFun/kraken")
library(devtools, dependencies = TRUE)
?library
?install_github
devtools::install_github("r-lib/rlang")
devtools::install_github("r-lib/rlang")
install.packages(c("animation", "ape", "assertthat", "backports", "bezier", "BH", "broom", "callr", "caTools", "cli", "clipr", "coda", "colorspace", "commonmark", "curl", "dbplyr", "devtools", "digest", "dplyr", "evaluate", "expm", "fansi", "forcats", "git2r", "glue", "gss", "gtable", "haven", "highr", "hms", "htmltools", "httpuv", "httr", "igraph", "jsonlite", "knitr", "later", "lazyeval", "lme4", "markdown", "mime", "modelr", "msm", "mvtnorm", "numDeriv", "openssl", "permute", "phangorn", "phytools", "pillar", "pkgbuild", "pkgconfig", "pkgload", "plotrix", "pracma", "processx", "promises", "ps", "purrr", "quadprog", "R6", "Rcpp", "readr", "readxl", "reprex", "rJava", "rmarkdown", "roxygen2", "rstudioapi", "rvest", "shiny", "stringi", "stringr", "svgViewR", "tibble", "tidyr", "tidyselect", "tinytex", "vegan", "whisker", "xfun", "xml2", "xtable"))
devtools::install_github("r-lib/rlang")
library(devtools)
library(devtools)
#### Loading libraries ####
if (!require("devtools")) {
install.packages("devtools", dependencies = TRUE)
library(devtools)
}
library(devtools)
devtools::install_github("r-lib/rlang")
install.packages("ggplot2", dependencies = TRUE)
install.packages("ggplot2", dependencies = TRUE)
install_github("MorphoFun/kraken")
library(devtools)
install.packages("usethis")
