vertical = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpV_BW)),
medioateral = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpML_BW)),
anteroposterior = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpAP_BW)),
net = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$NetGRF_BW))
)
### Combine the peak net GRF data
GRFs$Pelvic$Pel_GRFs_Filtered_PeakNet$appendage <- "pelvic"
GRFs$Pectoral$Pec_GRFs_Filtered_PeakNet$appendage <- "pectoral"
peakNetGRF <- rbind(GRFs$Pelvic$Pel_GRFs_Filtered_PeakNet, GRFs$Pectoral$Pec_GRFs_Filtered_PeakNet)
peakNetGRF$group <- paste(substring(peakNetGRF$filename, 1, 2), substring(peakNetGRF$appendage, 1, 3), sep = "_")
peakNetGRF$individual <- substring(peakNetGRF$filename, 1, 4)
#### PeakNetGRF: summary stats ####
variablesToAnalyze <- (c("PercentStance", "InterpV_BW", "InterpML_BW", "InterpAP_BW", "NetGRF_BW", "MLAngle_Convert_deg", "APAngle_Convert_deg", "group", "individual", "appendage"))
aggregate(. ~ group, data = peakNetGRF[,variablesToAnalyze[1:(length(variablesToAnalyze)-2)]], FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
nVars <- 7
## need to change this so it uses the subsetted data for the pectoral trials
## need to get rid of the redudant legends
# this shows how to get a common legend for combined plots: https://www.datanovia.com/en/lessons/combine-multiple-ggplots-into-a-figure/
p <- list()
for(i in 1:nVars){
p[[i]] <- ggplot(peakNetGRF, aes_string(x = variablesToAnalyze[8], y = variablesToAnalyze[i], fill = variablesToAnalyze[8])) +
geom_violin(trim = FALSE) +
geom_boxplot(width= 0.1, fill = "white") +
labs(x = "appendage", y = "variable") +
theme(legend.position = "none") +
theme_classic()
}
do.call(grid.arrange, p)
library(kraken)
library(lme4) # for lmer()
library(MuMIn) # for r.squaredGLMM()
library(emmeans) # for emmean() and contrast()
library(piecewiseSEM) # for rsquared()
library(gridExtra) # for grid.arrange()
library(car) # for qqPlot()
library(ggplot2) # for ggplot()
## need to change this so it uses the subsetted data for the pectoral trials
## need to get rid of the redudant legends
# this shows how to get a common legend for combined plots: https://www.datanovia.com/en/lessons/combine-multiple-ggplots-into-a-figure/
p <- list()
for(i in 1:nVars){
p[[i]] <- ggplot(peakNetGRF, aes_string(x = variablesToAnalyze[8], y = variablesToAnalyze[i], fill = variablesToAnalyze[8])) +
geom_violin(trim = FALSE) +
geom_boxplot(width= 0.1, fill = "white") +
labs(x = "appendage", y = "variable") +
theme(legend.position = "none") +
theme_classic()
}
do.call(grid.arrange, p)
p <- list()
for(i in 1:nVars){
p[[i]] <- ggplot(peakNetGRF, aes_string(x = variablesToAnalyze[8], y = variablesToAnalyze[i], fill = variablesToAnalyze[8])) +
geom_violin(trim = FALSE) +
geom_boxplot(width= 0.1, fill = "white") +
labs(x = "appendage", y = variablesToAnalyze[i]) +
theme(legend.position = "none") +
theme_classic()
}
do.call(grid.arrange, p)
## ggplot2 calculates more outliers bc baseplot::boxplot doesn't actually calculate the 1st and 3rd quantiles with even n
# https://stackoverflow.com/questions/21793715/why-geom-boxplot-identify-more-outliers-than-base-boxplot
boxplot_wOutliers <- function(df, x, y, group = NULL, label = NULL, ...) {
# calculate boxplot object
g <- ggplot(df, aes_string(x = x, y = y, fill = group)) + geom_boxplot() + guides(fill=FALSE)
# get list of outliers
out <- ggplot_build(g)[["data"]][[1]][["outliers"]]
# label list elements with factor levels
names(out) <- levels(as.factor(group))
# convert to tidy data
tidyout <- purrr::map_df(out, tibble::as_tibble, .id = "category")
tidyout$label <- df[,label][tidyout$value]
tidyout$group <- levels(as.factor(df[,group]))
# plot boxplots with labels
g + geom_text(data = tidyout, aes(group, value, label = label),  hjust = -0.1)  +
theme(legend.position = "none") +
theme_classic()
}
boxplot_wOutliers(peakNetGRF, x = "group", y = "PercentStance", group = "group", label = "filename")
removeOutliers <- function(df, x, y, ...) {
out <- boxplot(df[,y] ~ df[,x], col = rainbow(5), xlab = x, ylab = y)$out
outliers <- df[out,]
usableData <- df[-c(out),]
output <- list(
outliers = outliers,
usableData = usableData
)
return(output)
}
peakNetGRF_noOutliers <- removeOutliers(peakNetGRF, "group", "PercentStance")
peakNetGRF_noOutliers
## can't seem to get rid of the trials that are labeled as outliers
# the outliers that are determined by boxplot don't seem to be matching up with the plot
boxplot_wOutliers(peakNetGRF_noOutliers$usableData, x = "group", y = "PercentStance", group = "group", label = "filename")
## can't seem to get rid of the trials that are labeled as outliers
# the outliers that are determined by boxplot don't seem to be matching up with the plot
boxplot_wOutliers(peakNetGRF_noOutliers$usableData, x = "group", y = "PercentStance", group = "group", label = "filename")
outliers<-Boxplot(PercentStance ~ as.factor(group), data = peakNetGRF, id.method = peakNetGRF$filename)
peakNetGRF_noOutliers <- peakNetGRF[-as.numeric(outliers),]
str(peakNetGRF_noOutliers)
modelFormulae <- list()
pec_LMM <- list()
for (i in 1:nVars) {
modelFormulae[[i]] <- as.formula(paste(variablesToAnalyze[i], "~group+(1|individual)", sep = ""))
pec_LMM[[i]] <- lmer(modelFormulae[[i]], data = subset(peakNetGRF[,variablesToAnalyze], appendage == "pectoral"))
}
names(pec_LMM) <- modelFormulae
## testing out the car::qqPlot() function bc it provides confidence intervals around the qqline
qqPlot(resid(pec_LMM[[7]]))
## evaluating the normality of the residuals
qqplots <- list()
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
qqplots[[i]] <-   qqPlot(resid(pec_LMM[[i]]))
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
}
do.call(grid.arrange, qqplots)
names(pec_LMM_shapiro) <- modelFormulae
library(car)
## evaluating the normality of the residuals
qqplots <- list()
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
qqplots[[i]] <-   qqPlot(resid(pec_LMM[[i]]))
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
}
do.call(grid.arrange, qqplots)
do.call(grid.arrange, grobs = qqplots)
do.call(grid.arrange, qqplots, main = "testing normality")
do.call(grid.arrange(main = "testing normality"), qqplots)
do.call(grid.arrange, grobs = list(qqplots))
str(ggplots)
str(qwplots)
str(qqplots)
class(qqplots)
class(qqplots[[1]])
qqplots
qqplots[[1]]
qqplots[[i]] <-   qqPlot(resid(pec_LMM[[i]]))
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
#qqplots[[i]] <-   qqPlot(resid(pec_LMM[[i]]))
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
}
#do.call(grid.arrange, grobs = list(qqplots))
names(pec_LMM_shapiro) <- modelFormulae
#do.call(grid.arrange, grobs = list(qqplots)) # can't use grid.arrange on car plots
names(pec_LMM_shapiro) <- modelFormulae
pec_LMM_shapiro
str(peakNetGRF)
#### LMM: Peak net GRF Pec Comparison ####
## Pectoral GRF data to analyze
pec_peakNetGRFs <- subset(peakNetGRF, appendage == "pectoral")
str(pec_peakNetGRFs)
sal_peakNetGRFs <- subset(peakNetGRF, !substring(filename == "pb"))
sal_peakNetGRFs <- subset(peakNetGRF, !substring(filename, 1, 2) == "pb")
str(sal_peakNetGRFs)
ok <- subset(peakNetGRF, substring(filename, 1, 2) == "pb")
str(ok)
str(sal_peakNetGRFs)
sal_peakNetGRFs
modelFormulae <- list()
pec_LMM <- list()
for (i in 1:nVars) {
modelFormulae[[i]] <- as.formula(paste(variablesToAnalyze[i], "~group+(1|individual)", sep = ""))
pec_LMM[[i]] <- lmer(modelFormulae[[i]], data = pec_peakNetGRFs)
}
names(pec_LMM) <- modelFormulae
## trying to log-transform to help with normality but can't take the log of negative numbers
modelFormulae_log <- list()
pec_LMM_log <- list()
for (i in 1:nVars) {
modelFormulae_log[[i]] <- as.formula(paste("log(", variablesToAnalyze[i], ")~group+(1|individual)", sep = ""))
pec_LMM_log[[i]] <- lmer(modelFormulae_log[[i]], data = pec_peakNetGRFs)
}
names(pec_LMM_log) <- modelFormulae_log
pec_LMM
head(pec_peakNetGRFs)
## b) evaluating the normality of the residuals
# the null of the Shapiro-Wilk test is that the input (e.g., residuals of data) are normal
qqplots <- list()
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
#qqplots[[i]] <-   qqPlot(resid(pec_LMM[[i]]))
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
}
#do.call(grid.arrange, grobs = list(qqplots)) # can't use grid.arrange on car plots
names(pec_LMM_shapiro) <- modelFormulae
pec_LMM_shapiro
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
qqPlot(resid(pec_LMM[[1]]))
}
?qqPlot
names(pec_LMM)
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
qqPlot(resid(pec_LMM[[1]]), ylab = names(pec_LMM)[[i]])
}
?shapiro.test
summary(pec_LMM_shapiro)
summary(pec_LMM_shapiro[[1]])
leveneTest(. ~ group, data = pec_peakNetGRFs)
leveneTest(PercentStance ~ group, data = pec_peakNetGRFs)
leveneTest(PercentStance ~ as.factor(group), data = pec_peakNetGRFs)
fligner.test(PercentStance ~ as.factor(group), data = pec_peakNetGRFs)
variablesToAnalyze
pec_LMM_levene <- list()
pec_LMM_fligner <- list()
for (i in 1:nVars) {
pec_LMM_levene[[i]] <- leveneTest(i ~ as.factor(group), data = pec_peakNetGRFs[,variablesToAnalyze])
pec_LMM_fligner[[i]] <- fligner.test(i ~ as.factor(group), data = pec_peakNetGRFs[,variablesToAnalyze])
}
names(pec_peakNetGRFs)
pec_LMM_levene <- list()
pec_LMM_fligner <- list()
for (i in 1:nVars+1) {
pec_LMM_levene[[i]] <- leveneTest(i ~ as.factor(group), data = pec_peakNetGRFs[,variablesToAnalyze])
pec_LMM_fligner[[i]] <- fligner.test(i ~ as.factor(group), data = pec_peakNetGRFs[,variablesToAnalyze])
}
pec_LMM_levene <- list()
pec_LMM_fligner <- list()
for (i in 1:nVars) {
pec_LMM_levene[[i]] <- leveneTest(i ~ as.factor(group), data = pec_peakNetGRFs[,variablesToAnalyze])
}
lapply(pec_peakNetGRFs, FUN = function(x) leveneTest(x ~ as.factor(x$group)))
str(pec_peakNetGRFs)
pec_LMM_levene <- list()
pec_LMM_fligner <- list()
for (i in 1:nVars) {
pec_LMM_levene[[i]] <- leveneTest(i ~ as.factor(group), data = pec_peakNetGRFs)
}
variablesToAnalyze
lapply(pec_peakNetGRFs, FUN = function(x) leveneTest(x ~ as.factor(x$group)))
sapply(pec_peakNetGRFs, FUN = function(x) leveneTest(x ~ as.factor(x$group)))
responses <- as.matrix(mtcars[,-c(4,8,9)])
responses
variablesToAnalyze
apply(pec_peakNetGRFs[,variablesToAnalyze[1:7]],2,function(x) {leveneTest(x ~ as.factor(group))})
apply(pec_peakNetGRFs[,variablesToAnalyze[1:7]],2,function(x) {leveneTest(x ~ as.factor(pec_peakNetGRFs$group))})
apply(pec_peakNetGRFs[,variablesToAnalyze[1:7]],2,function(x) {fligner.test(x ~ as.factor(pec_peakNetGRFs$group))})
boxplot_wOutliers <- function(df, x, y, group = NULL, label = NULL, ...) {
# calculate boxplot object
g <- ggplot(df, aes_string(x = x, y = y, fill = group)) + geom_boxplot() + guides(fill=FALSE)
# get list of outliers
out <- ggplot_build(g)[["data"]][[1]][["outliers"]]
# label list elements with factor levels
names(out) <- levels(as.factor(group))
# convert to tidy data
tidyout <- purrr::map_df(out, tibble::as_tibble, .id = "category")
tidyout$label <- df[,label][tidyout$value]
tidyout$group <- levels(as.factor(df[,group]))
# plot boxplots with labels
g + geom_text(data = tidyout, aes(group, value, label = label),  hjust = -0.1)  +
theme(legend.position = "none") +
theme_classic()
}
boxplot_wOutliers(peakNetGRF, x = "group", y = "PercentStance", group = "group", label = "filename")
removeOutliers <- function(df, x, y, ...) {
out <- boxplot(df[,y] ~ df[,x], col = rainbow(5), xlab = x, ylab = y)$out
outliers <- df[out,]
usableData <- df[-c(out),]
output <- list(
outliers = outliers,
usableData = usableData
)
return(output)
}
peakNetGRF_noOutliers <- removeOutliers(peakNetGRF, "group", "PercentStance")
## can't seem to get rid of the trials that are labeled as outliers
# the outliers that are determined by boxplot don't seem to be matching up with the plot
boxplot_wOutliers(peakNetGRF_noOutliers$usableData, x = "group", y = "PercentStance", group = "group", label = "filename")
names(peakNetGRF_noOutliers)
peakNetGRF_noOutliers$outliers
## need to change this so it uses the subsetted data for the pectoral trials
## need to get rid of the redudant legends
# this shows how to get a common legend for combined plots: https://www.datanovia.com/en/lessons/combine-multiple-ggplots-into-a-figure/
p <- list()
for(i in 1:nVars){
p[[i]] <- ggplot(pec_peakNetGRFs, aes_string(x = variablesToAnalyze[8], y = variablesToAnalyze[i], fill = variablesToAnalyze[8])) +
geom_violin(trim = FALSE) +
geom_boxplot(width= 0.1, fill = "white") +
labs(x = "appendage", y = variablesToAnalyze[i]) +
theme(legend.position = "none") +
theme_classic()
}
do.call(grid.arrange, p)
boxplot_wOutliers(pec_peakNetGRFs, x = "group", y = "PercentStance", group = "group", label = "filename")
removeOutliers <- function(df, x, y, ...) {
out <- boxplot(df[,y] ~ df[,x], col = rainbow(5), xlab = x, ylab = y)$out
outliers <- df[out,]
usableData <- df[-c(out),]
output <- list(
outliers = outliers,
usableData = usableData
)
return(output)
}
peakNetGRF_noOutliers <- removeOutliers(peakNetGRF, "group", "PercentStance")
pec_peakNetGRF_noOutliers <- removeOutliers(peakNetGRF, "group", "PercentStance")
pec_peakNetGRF_noOutliers$outliers
pec_peakNetGRF_noOutliers <- removeOutliers(pec_peakNetGRF_noOutliers, "group", "PercentStance")
pec_peakNetGRF_noOutliers <- removeOutliers(pec_peakNetGRFs, "group", "PercentStance")
pec_peakNetGRF_noOutliers$outliers
## can't seem to get rid of the trials that are labeled as outliers
# the outliers that are determined by boxplot don't seem to be matching up with the plot
boxplot_wOutliers(pec_peakNetGRF_noOutliers$usableData, x = "group", y = "PercentStance", group = "group", label = "filename")
boxplot(PercentStance ~ group, data = pec_peakNetGRF_noOutliers)
boxplot(PercentStance ~ group, data = pec_peakNetGRF_noOutliers$usableData)
pec_peakNetGRF_noOutliers$usableData
str(pec_peakNetGRF_noOutliers$usableData)
str(pec_peakNetGRF_noOutliers$outliers)
str(pec_peakNetGRFs)
pec_percentstance_bp <- boxplot(PercentStance ~ group, data = pec_peakNetGRF_noOutliers$usableData)
pec_percentstance_bp$out
df <- pec_peakNetGRFs
x = "group"
y = "PercentStance"
out <- boxplot(df[,y] ~ df[,x], col = rainbow(5), xlab = x, ylab = y)$out
out
outliers <- df[which(df[,y] == out),]
outliers
outliers
out
outliers <- df[which(df[,y] == c(out)),]
outliers
outliers <- df[df[,y] %in% outliers,]
outliers <- df[df[,y] %in% out,]
outliers
out
out <- boxplot(df[,y] ~ df[,x], col = rainbow(5), xlab = x, ylab = y)$out
outliers <- df[df[,y] %in% out,]
outliers
out
>boxplot
?boxplot
pec_peakNetGRF_noOutliers <- removeOutliers(pec_peakNetGRFs, "group", "PercentStance")
variable <- pec_peakNetGRFs$PercentStance
out <- boxplot(variable, ylab = variable)$out
?boxplot
out <- boxplot(variable)$out
out
y <- pec_peakNetGRFs$PercentStance
## subset data to get different sets of outliers?
for (i in 1:length(y)) {
out <- boxplot(df[,y[i]] ~ df[,x], ylab = y[i])$out
}
y
out <- boxplot(df[,y ~ df[,x], ylab = y)$out
}
for (i in 1:length(y)) {
out <- boxplot(df[,y[i]] ~ df[,x], ylab = y[i])$out
}
out <- boxplot(df[,y] ~ df[,x], col = rainbow(5), xlab = x, ylab = y)$out
outliers <- df[df[,y] %in% out,] ## need to edit this; identifies values corresponding to outlier values but not the exact outliers
usableData <- df[-c(out),]
output <- list(
outliers = outliers,
usableData = usableData
)
return(output)
}
pec_peakNetGRF_noOutliers <- removeOutliers(pec_peakNetGRFs, "group", "PercentStance")
pec_percentstance_bp <- boxplot(PercentStance ~ group, data = pec_peakNetGRF_noOutliers$usableData)
## can't seem to get rid of the trials that are labeled as outliers
# the outliers that are determined by boxplot don't seem to be matching up with the plot
boxplot_wOutliers(pec_peakNetGRF_noOutliers$usableData, x = "group", y = "PercentStance", group = "group", label = "filename")
outliers<-Boxplot(PercentStance ~ as.factor(group), data = peakNetGRF, id.method = peakNetGRF$filename)
peakNetGRF_noOutliers <- peakNetGRF[-as.numeric(outliers),]
#### LINEAR MIXED EFFECTS MODELS ####
## This will be used to compare the means between groups while accounting for the repeated trials within individuals
## Since there are no pelvic data for Periophthalmus, we'll have three models:
## 1) pectoral comparison between Periophthalmus, Ambystoma, and Pleurodeles
## 2) pelvic comparison between Amvbystoma and Pleurodeles
## 3) pectoral versus pelvic for Ambystoma and Pleurodeles
## The effect sizes of individual independent variables can be assessed through the fixed effects:
## https://stat.ethz.ch/pipermail/r-sig-mixed-models/2013q4/021102.html
## Or, could consider the f2 value (Aiken and West 1991): https://largescaleassessmentsineducation.springeropen.com/articles/10.1186/s40536-018-0061-2
#### LMM: Peak net GRF Pec Comparison ####
### a) Run lmers
modelFormulae <- list()
pec_LMM <- list()
for (i in 1:nVars) {
modelFormulae[[i]] <- as.formula(paste(variablesToAnalyze[i], "~group+(1|individual)", sep = ""))
pec_LMM[[i]] <- lmer(modelFormulae[[i]], data = pec_peakNetGRFs)
}
names(pec_LMM) <- modelFormulae
# ## trying to log-transform to help with normality but can't take the log of negative numbers
# modelFormulae_log <- list()
# pec_LMM_log <- list()
# for (i in 1:nVars) {
#   modelFormulae_log[[i]] <- as.formula(paste("log(", variablesToAnalyze[i], ")~group+(1|individual)", sep = ""))
#   pec_LMM_log[[i]] <- lmer(modelFormulae_log[[i]], data = pec_peakNetGRFs)
#
# }
# names(pec_LMM_log) <- modelFormulae_log
### Testing the assumptions
## Don't need to test for linearity of data because the predictors are categorical
## b) evaluating the normality of the residuals
# the null of the Shapiro-Wilk test is that the input (e.g., residuals of data) are normal
pec_LMM_shapiro <- list()
for (i in 1:nVars) {
pec_LMM_shapiro[[i]] <- shapiro.test(resid(pec_LMM[[i]]))
qqPlot(resid(pec_LMM[[1]]), ylab = names(pec_LMM)[[i]])
}
#do.call(grid.arrange, grobs = list(qqplots)) # can't use grid.arrange on car plots
names(pec_LMM_shapiro) <- modelFormulae
# Only InterpAP_BW met the assumption of normality based on the Shapiro-Wilk tests
# However, the graphs show that the values tended to deviate from normality mainly because
# the smallest points tended to underestimate the fitted values, which is more conservative
# than having the largest values overestimate the qq-line
## c) Testing homogeneity of variances
# the Bartlett's test is more sensitive to non-normal data so people often use Levene's
# more info here; http://www.sthda.com/english/wiki/compare-multiple-sample-variances-in-r
# The Fligner-Killeen test can be used for non-normal data
apply(pec_peakNetGRFs[,variablesToAnalyze[1:7]],2,function(x) {leveneTest(x ~ as.factor(pec_peakNetGRFs$group))})
apply(pec_peakNetGRFs[,variablesToAnalyze[1:7]],2,function(x) {fligner.test(x ~ as.factor(pec_peakNetGRFs$group))})
### Continuing on with statistical analyses since data seem to meet assumptions of LMM
## Zu omega squared to assess the 'goodness of fit' for the entire model
# Xu's omega method: http://onlinelibrary.wiley.com/doi/10.1002/sim.1572/abstract
## or through the performance package: (got the same exact results as my code)
# performance::r2_xu(pec_LMM)
Xu_omega2 <- function(lmm, ...) {
1-var(residuals(lmm))/(var(model.response(model.frame(lmm))))
}
pec_LMM_omega2 <- lapply(pec_LMM, FUN = function(x) Xu_omega2(x))
## Can also do post-hoc pair-wise comparisons for the fixed effects: https://stats.stackexchange.com/questions/237512/how-to-perform-post-hoc-test-on-lmer-model
## This describes that the differences between the post-hoc options: https://stats.stackexchange.com/questions/204741/which-multiple-comparison-method-to-use-for-a-lmer-model-lsmeans-or-glht
## The main difference is how they calculate the p-value, which doesn't matter to LMMs.
## multcomp::glht() can produces shorter CIs and small p-values (which may be due to assumming infinite dfs),
## so might be better to use lsmeans::lsmeans() to be more conservative.
## lsmeans also handles interactions better.
## lsmeans has migrated to emmeans. This describes how to get the contrasts:
## https://stats.stackexchange.com/questions/331238/post-hoc-pairwise-comparison-of-interaction-in-mixed-effects-lmer-model
## and https://stats.stackexchange.com/questions/355611/pairwise-comparisons-with-emmeans-for-a-mixed-three-way-interaction-in-a-linear
# pec_EMM <- emmeans(pec_LMM[[1]], ~ group)
# contrast(pec_EMM[[1]], interaction = "pairwise")
pec_EMM <- lapply(pec_LMM, FUN = function(x) emmeans(x, ~ group))
pec_EMM_contrasts <- lapply(pec_EMM, FUN = function(x) contrast(x, interaction = "pairwise"))
## Cohen's f2 to estimate the effect size of a fixed effect: https://github.com/finch-f/effect-size-in-Linear-mixed-model/blob/master/How%20to%20calculate%20effect%20size%20of%20a%20fixed%20effect.pdf
Cohen_f2 <- function(y, FE = NULL, RE = NULL, df = NULL, ...) {
LMM_formula <- as.formula(paste(y, " ~ ", FE, " + ", RE))
LMM <- lmer(LMM_formula, data = df)
LMM_null_formula <- as.formula(paste(y, " ~ 1 + ", RE))
LMM_null <- lmer(LMM_null_formula, data = df)
LMM_pseudoR2 <- piecewiseSEM::rsquared(LMM)
LMM_null_pseudoR2 <- piecewiseSEM::rsquared(LMM_null)
LMM_f2 <- (LMM_pseudoR2[,5:6] - LMM_null_pseudoR2[,5:6])/(1 - LMM_pseudoR2[,5:6])
# double-check last line bc I got a conditional f2 that was lower than the marginal, which shouldn't be possible
# maybe that's because I should only be calculating the f2 for the marginal values
}
pec_LMM_null <- lmer(PercentStance ~ 1 + (1 |individual), data = subset(peakNetGRF, appendage == "pectoral"), REML = TRUE)
pec_LMM_pseudoR2 <- piecewiseSEM::rsquared(pec_LMM)
pec_LMM_null_pseudoR2 <- piecewiseSEM::rsquared(pec_LMM_null)
pec_LMM_F2 <- (pec_LMM_null_pseudoR2 - pec_LMM_pseudoR2)/(1 - pec_LMM_null_pseudoR2)
# got a lot of warnings about "In Ops.factor(left, right) : ‘-’ not meaningful for factors"
pec_LMM_F2 <- (pec_LMM_pseudoR2[,5:6] - pec_LMM_null_pseudoR2[,5:6])/(1 - pec_LMM_pseudoR2[,5:6])
# this worked, though. Values were different from MuMIn::r.squaredGLMM(pec_LMM)
# using the marginal values since Cohen's f2 is based on the fixed effects, and the conditional value includes both the fixed and random effects.
## when plotting the vertical and net GRF data, maybe use filled regions to help highlight the areas of overlap
#### YANK ####
yank_pec <- list(
vertical = lapply(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpV_BW)),
medioateral = lapply(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpML_BW)),
anteroposterior = lapply(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpAP_BW)),
net = lapply(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$NetGRF_BW))
)
yank_pel <- list(
vertical = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpV_BW)),
medioateral = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpML_BW)),
anteroposterior = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$InterpAP_BW)),
net = lapply(GRFs$Pelvic$Pec_GRFs_Filtered_dataset_noOverlap, function(x) yank(x$PercentStance, x$NetGRF_BW))
)
#### SAVING THE DATA ####
## go to the parent directory then save output in 'output' folder
setwd('..')
setwd('..')
setwd('./output')
## Pectoral data
## Save the dataset that was filtered and had areas of overlap excluded
Save_FilterAll_Pec <- NULL
for (i in 1:length(GRFs$Pectoral$Pec_GRFs_Filtered_dataset)) {
Save_FilterAll_Pec[[i]] <- paste(names(GRFs$Pectoral$Pec_GRFs_Filtered_dataset)[[i]], "_Pec_Filtered_",SaveDate, ".csv", sep="")
write.table(GRFs$Pectoral$Pec_GRFs_Filtered_dataset[[i]], file = Save_FilterAll_Pec[[i]], sep =",", row.names=FALSE)
}
## Save the dataset that was filtered and had areas of overlap excluded
Save_FilterNoOverlap_Pec <- NULL
for (i in 1:length(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap)) {
Save_FilterNoOverlap_Pec[[i]] <- paste(names(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap)[[i]], "_Pec_Filtered_noOverlap_",SaveDate, ".csv", sep="")
write.table(GRFs$Pectoral$Pec_GRFs_Filtered_dataset_noOverlap[[i]], file = Save_FilterNoOverlap_Pec[[i]], sep =",", row.names=FALSE)
}
## Save the data taken at the peak Net GRF
Save_FilterNoOverlap_PeakNet_Pec <- paste("FinLimbs_Pec_Filtered_noOverlap_Peak_",SaveDate, ".csv", sep="")
write.table(GRFs$Pectoral$Pec_GRFs_Filtered_PeakNet, file = Save_FilterNoOverlap_PeakNet_Pec, sep =",", row.names=FALSE)
## Pelvic data
## Save the dataset that was filtered and had areas of overlap excluded
Save_FilterAll_Pel <- NULL
for (i in 1:length(GRFs$Pelvic$Pel_GRFs_Filtered_dataset)) {
Save_FilterAll_Pel[[i]] <- paste(names(GRFs$Pelvic$Pel_GRFs_Filtered_dataset)[[i]], "_Pel_Filtered_",SaveDate, ".csv", sep="")
write.table(GRFs$Pelvic$Pel_GRFs_Filtered_dataset[[i]], file = Save_FilterAll_Pel[[i]], sep =",", row.names=FALSE)
}
## Save the dataset that was filtered and had areas of overlap excluded
Save_FilterNoOverlap_Pel <- NULL
for (i in 1:length(GRFs$Pelvic$Pel_GRFs_Filtered_dataset_noOverlap)) {
Save_FilterNoOverlap_Pel[[i]] <- paste(names(GRFs$Pelvic$Pel_GRFs_Filtered_dataset_noOverlap)[[i]], "_Pel_Filtered_noOverlap_",SaveDate, ".csv", sep="")
write.table(GRFs$Pelvic$Pel_GRFs_Filtered_dataset_noOverlap[[i]], file = Save_FilterNoOverlap_Pel[[i]], sep =",", row.names=FALSE)
}
## Save the data taken at the peak Net GRF
Save_FilterNoOverlap_PeakNet_Pel <- paste("FinLimbs_Pel_Filtered_noOverlap_Peak_",SaveDate, ".csv", sep="")
write.table(GRFs$Pelvic$Pel_GRFs_Filtered_PeakNet, file = Save_FilterNoOverlap_PeakNet_Pel, sep =",", row.names=FALSE)
getwd()
